#!/usr/bin/env ruby
# frozen_string_literal: true

require "exa-ai"

# Parse command-line arguments
def parse_args(argv)
  args = {
    output_format: "json",
    api_key: nil
  }

  # Extract URL (first non-flag argument)
  url_found = false
  i = 0
  while i < argv.length
    arg = argv[i]
    case arg
    when "--num-results"
      args[:num_results] = argv[i + 1].to_i
      i += 2
    when "--exclude-source-domain"
      args[:exclude_source_domain] = true
      i += 1
    when "--category"
      category = argv[i + 1]
      valid_categories = ["company", "research paper", "news", "pdf", "github", "tweet", "personal site", "linkedin profile", "financial report"]
      unless valid_categories.include?(category)
        $stderr.puts "Error: Category must be one of: #{valid_categories.map { |c| "\"#{c}\"" }.join(', ')}"
        exit 1
      end
      args[:category] = category
      i += 2
    when "--include-domains"
      args[:include_domains] = argv[i + 1].split(",").map(&:strip)
      i += 2
    when "--exclude-domains"
      args[:exclude_domains] = argv[i + 1].split(",").map(&:strip)
      i += 2
    when "--start-published-date"
      args[:start_published_date] = argv[i + 1]
      i += 2
    when "--end-published-date"
      args[:end_published_date] = argv[i + 1]
      i += 2
    when "--start-crawl-date"
      args[:start_crawl_date] = argv[i + 1]
      i += 2
    when "--end-crawl-date"
      args[:end_crawl_date] = argv[i + 1]
      i += 2
    when "--include-text"
      args[:include_text] ||= []
      args[:include_text] << argv[i + 1]
      i += 2
    when "--exclude-text"
      args[:exclude_text] ||= []
      args[:exclude_text] << argv[i + 1]
      i += 2
    when "--text"
      args[:text] = true
      i += 1
    when "--text-max-characters"
      args[:text_max_characters] = argv[i + 1].to_i
      i += 2
    when "--include-html-tags"
      args[:include_html_tags] = true
      i += 1
    when "--summary"
      args[:summary] = true
      i += 1
    when "--summary-query"
      args[:summary_query] = argv[i + 1]
      i += 2
    when "--summary-schema"
      schema_arg = argv[i + 1]
      args[:summary_schema] = if schema_arg.start_with?("@")
                               JSON.parse(File.read(schema_arg[1..]))
                             else
                               JSON.parse(schema_arg)
                             end
      i += 2
    when "--api-key"
      args[:api_key] = argv[i + 1]
      i += 2
    when "--output-format"
      args[:output_format] = argv[i + 1]
      i += 2
    when "--help", "-h"
      puts <<~HELP
        Usage: exa-ai find-similar URL [OPTIONS]

        Find content similar to a given URL

        Arguments:
          URL                       URL to find similar content for (required)

        Options:
          --num-results N              Number of results to return (default: 10)
          --exclude-source-domain      Exclude results from the source URL's domain
          --category CAT               Focus on specific data category
                                       Options: "company", "research paper", "news", "pdf",
                                       "github", "tweet", "personal site", "linkedin profile",
                                       "financial report"
          --include-domains D          Comma-separated list of domains to include
          --exclude-domains D          Comma-separated list of domains to exclude
          --start-published-date DATE  Filter by published date (ISO 8601 format)
          --end-published-date DATE    Filter by published date (ISO 8601 format)
          --start-crawl-date DATE      Filter by crawl date (ISO 8601 format)
          --end-crawl-date DATE        Filter by crawl date (ISO 8601 format)
          --include-text PHRASE        Include results with exact phrase (repeatable)
          --exclude-text PHRASE        Exclude results with exact phrase (repeatable)

        Content Extraction:
          --text                       Include full webpage text
          --text-max-characters N      Max characters for webpage text
          --include-html-tags          Include HTML tags in text extraction
          --summary                    Include AI-generated summary
          --summary-query PROMPT       Custom prompt for summary generation
          --summary-schema FILE        JSON schema for summary structure (@file syntax)

        General Options:
          --api-key KEY                Exa API key (or set EXA_API_KEY env var)
          --output-format FMT          Output format: json, pretty, or text (default: json)
          --help, -h                   Show this help message

        Examples:
          exa-ai find-similar "https://example.com/article"
          exa-ai find-similar "https://techcrunch.com/ai-startup" --num-results 5
          exa-ai find-similar "https://arxiv.org/paper" --category "research paper"
          exa-ai find-similar "https://example.com" --exclude-source-domain
          exa-ai find-similar "https://example.com" --output-format pretty
      HELP
      exit 0
    else
      unless url_found
        args[:url] = arg
        url_found = true
      end
      i += 1
    end
  end

  args
end

# Build contents parameter from extracted flags
def build_contents(args)
  contents = {}

  # Text options
  if args[:text]
    if args[:text_max_characters] || args[:include_html_tags]
      contents[:text] = {}
      contents[:text][:max_characters] = args[:text_max_characters] if args[:text_max_characters]
      contents[:text][:include_html_tags] = args[:include_html_tags] if args[:include_html_tags]
    else
      contents[:text] = true
    end
  end

  # Summary options
  if args[:summary]
    if args[:summary_query] || args[:summary_schema]
      contents[:summary] = {}
      contents[:summary][:query] = args[:summary_query] if args[:summary_query]
      contents[:summary][:schema] = args[:summary_schema] if args[:summary_schema]
    else
      contents[:summary] = true
    end
  end

  contents.empty? ? nil : contents
end

# Main execution
begin
  args = parse_args(ARGV)

  # Validate URL
  if args[:url].nil? || args[:url].empty?
    $stderr.puts "Error: URL is required"
    $stderr.puts "Run 'exa-ai find-similar --help' for usage information"
    exit 1
  end

  # Resolve API key
  api_key = Exa::CLI::Base.resolve_api_key(args[:api_key])

  # Resolve output format
  output_format = Exa::CLI::Base.resolve_output_format(args[:output_format])

  # Build client
  client = Exa::CLI::Base.build_client(api_key)

  # Prepare parameters
  params = {}
  params[:numResults] = args[:num_results] if args[:num_results]
  params[:excludeSourceDomain] = args[:exclude_source_domain] if args[:exclude_source_domain]
  params[:category] = args[:category] if args[:category]
  params[:includeDomains] = args[:include_domains] if args[:include_domains]
  params[:excludeDomains] = args[:exclude_domains] if args[:exclude_domains]
  params[:start_published_date] = args[:start_published_date] if args[:start_published_date]
  params[:end_published_date] = args[:end_published_date] if args[:end_published_date]
  params[:start_crawl_date] = args[:start_crawl_date] if args[:start_crawl_date]
  params[:end_crawl_date] = args[:end_crawl_date] if args[:end_crawl_date]
  params[:include_text] = args[:include_text] if args[:include_text]
  params[:exclude_text] = args[:exclude_text] if args[:exclude_text]
  contents = build_contents(args)
  params.merge!(contents) if contents

  # Execute find_similar
  result = client.find_similar(args[:url], **params)

  # Format and output result
  output = Exa::CLI::Formatters::SearchFormatter.format(result, output_format)
  puts output

rescue Exa::ConfigurationError => e
  $stderr.puts "Configuration error: #{e.message}"
  exit 1
rescue Exa::Unauthorized => e
  $stderr.puts "Authentication error: #{e.message}"
  $stderr.puts "Check your API key (set EXA_API_KEY or use --api-key)"
  exit 1
rescue Exa::ClientError => e
  $stderr.puts "Client error: #{e.message}"
  exit 1
rescue Exa::ServerError => e
  $stderr.puts "Server error: #{e.message}"
  $stderr.puts "The Exa API may be experiencing issues. Please try again later."
  exit 1
rescue Exa::Error => e
  $stderr.puts "Error: #{e.message}"
  exit 1
rescue StandardError => e
  $stderr.puts "Unexpected error: #{e.message}"
  $stderr.puts e.backtrace.first(5) if ENV["DEBUG"]
  exit 1
end
