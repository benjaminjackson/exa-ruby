#!/usr/bin/env ruby
# frozen_string_literal: true

# Set up load paths
require "bundler/setup"
require "exa"
require "exa/cli/base"
require "exa/cli/formatters/answer_formatter"

# Parse command-line arguments
def parse_args(argv)
  args = {
    output_format: "json",
    api_key: nil,
    text: false,
    stream: false
  }

  # Extract query (first non-flag argument)
  query_parts = []
  i = 0
  while i < argv.length
    arg = argv[i]
    case arg
    when "--text"
      args[:text] = true
      i += 1
    when "--stream"
      args[:stream] = true
      i += 1
    when "--output-schema"
      args[:output_schema] = argv[i + 1]
      i += 2
    when "--system-prompt"
      args[:system_prompt] = argv[i + 1]
      i += 2
    when "--api-key"
      args[:api_key] = argv[i + 1]
      i += 2
    when "--output-format"
      args[:output_format] = argv[i + 1]
      i += 2
    when "--help", "-h"
      puts <<~HELP
        Usage: exa-api answer QUERY [OPTIONS]

        Generate an answer to a question using Exa AI

        Arguments:
          QUERY                 Question or query to answer (required)

        Options:
          --stream              Stream answer chunks in real-time
          --text                Include full text content from sources
          --output-schema JSON  JSON schema for structured output
          --system-prompt TEXT  System prompt to guide answer generation
          --api-key KEY         Exa API key (or set EXA_API_KEY env var)
          --output-format FMT   Output format: json, pretty, or text (default: json)
          --help, -h            Show this help message

        Examples:
          exa-api answer "What is the capital of France?"
          exa-api answer "Latest AI breakthroughs" --stream
          exa-api answer "Latest AI breakthroughs" --text
          exa-api answer "Ruby best practices" --output-format pretty
          exa-api answer "What is the capital of France?" --output-schema '{"type":"object","properties":{"city":{"type":"string"},"state":{"type":"string"}}}'
          exa-api answer "What is Paris?" --system-prompt "Respond in the voice of a pirate"
      HELP
      exit 0
    else
      query_parts << arg
      i += 1
    end
  end

  args[:query] = query_parts.join(" ")
  args
end

# Main execution
begin
  args = parse_args(ARGV)

  # Validate query
  if args[:query].nil? || args[:query].empty?
    $stderr.puts "Error: Query is required"
    $stderr.puts "Run 'exa-api answer --help' for usage information"
    exit 1
  end

  # Resolve API key
  api_key = Exa::CLI::Base.resolve_api_key(args[:api_key])

  # Resolve output format
  output_format = Exa::CLI::Base.resolve_output_format(args[:output_format])

  # Build client
  client = Exa::CLI::Base.build_client(api_key)

  # Prepare answer parameters
  answer_params = {}
  answer_params[:text] = args[:text] if args[:text]
  answer_params[:system_prompt] = args[:system_prompt] if args[:system_prompt]

  # Parse output_schema as JSON if provided
  if args[:output_schema]
    begin
      answer_params[:output_schema] = JSON.parse(args[:output_schema])
    rescue JSON::ParserError => e
      $stderr.puts "Error: Invalid JSON in --output-schema: #{e.message}"
      exit 1
    end
  end

  # Execute answer or streaming answer
  if args[:stream]
    # Streaming mode - output chunks in real-time
    client.answer_stream(args[:query], **answer_params) do |chunk|
      # Extract content from the streaming response format
      # API returns: {"choices":[{"delta":{"content":"..."}}]}
      if chunk["choices"]&.first&.dig("delta", "content")
        print chunk["choices"][0]["delta"]["content"]
        $stdout.flush
      end
    end
    puts # Add newline at the end
  else
    # Non-streaming mode - collect full response and format
    result = client.answer(args[:query], **answer_params)
    output = Exa::CLI::Formatters::AnswerFormatter.format(result, output_format)
    puts output
  end

rescue Exa::ConfigurationError => e
  $stderr.puts "Configuration error: #{e.message}"
  exit 1
rescue Exa::Unauthorized => e
  $stderr.puts "Authentication error: #{e.message}"
  $stderr.puts "Check your API key (set EXA_API_KEY or use --api-key)"
  exit 1
rescue Exa::ClientError => e
  $stderr.puts "Client error: #{e.message}"
  exit 1
rescue Exa::ServerError => e
  $stderr.puts "Server error: #{e.message}"
  $stderr.puts "The Exa API may be experiencing issues. Please try again later."
  exit 1
rescue Exa::Error => e
  $stderr.puts "Error: #{e.message}"
  exit 1
rescue StandardError => e
  $stderr.puts "Unexpected error: #{e.message}"
  $stderr.puts e.backtrace.first(5) if ENV["DEBUG"]
  exit 1
end
