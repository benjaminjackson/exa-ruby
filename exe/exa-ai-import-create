#!/usr/bin/env ruby
# frozen_string_literal: true

require "exa-ai"

VALID_FORMATS = Exa::Constants::Websets::IMPORT_FORMATS
VALID_ENTITY_TYPES = Exa::Constants::Websets::ENTITY_TYPES

# Recursively convert hash keys from strings to symbols
def deep_symbolize_keys(obj)
  case obj
  when Hash
    obj.each_with_object({}) do |(key, value), result|
      result[key.to_sym] = deep_symbolize_keys(value)
    end
  when Array
    obj.map { |item| deep_symbolize_keys(item) }
  else
    obj
  end
end

# Parse JSON string or load from file (supports @file.json syntax)
def parse_json_or_file(value)
  json_data = if value.start_with?("@")
                file_path = value[1..]
                JSON.parse(File.read(file_path))
              else
                JSON.parse(value)
              end
  deep_symbolize_keys(json_data)
rescue JSON::ParserError => e
  $stderr.puts "Error: Invalid JSON: #{e.message}"
  exit 1
rescue Errno::ENOENT => e
  $stderr.puts "Error: File not found: #{e.message}"
  exit 1
end

# Parse command-line arguments
def parse_args(argv)
  # Check for help first
  if argv.include?("--help") || argv.include?("-h")
    puts <<~HELP
      Usage: exa-ai import-create FILE [OPTIONS]

      Create a new import and upload external data file

      Arguments:
        FILE                      Path to the CSV file to upload

      Required:
        --count N                 Number of entities in the import
        --title TEXT              Display title
        --format TYPE             Format type (default: csv, options: #{VALID_FORMATS.join(', ')})
        --entity-type TYPE        Entity type (options: #{VALID_ENTITY_TYPES.join(', ')})

      Options:
        --entity-description TXT  Description for custom entity type (required with --entity-type custom)
        --csv-identifier N        CSV column identifier (0-indexed)
        --metadata JSON           Custom metadata (supports @file.json)
        --quiet                   Suppress normal output (only show errors)
        --api-key KEY             Exa API key (or set EXA_API_KEY env var)
        --output-format FMT       Output format: json, pretty, or text (default: json)
        --help, -h                Show this help message

      Examples:
        exa-ai import-create data.csv --count 100 --title "My Companies" --format csv --entity-type company
        exa-ai import-create companies.csv --count 50 --title "Tech Startups" --format csv --entity-type company --csv-identifier 0
        exa-ai import-create import.csv --count 100 --title "Import" --format csv --entity-type company --metadata '{"source":"crm"}' --quiet
    HELP
    exit 0
  end

  # First argument should be the file path
  if argv.empty? || argv[0].start_with?("--")
    $stderr.puts "Error: FILE argument is required"
    $stderr.puts "Run 'exa-ai import-create --help' for usage information"
    exit 1
  end

  args = {
    file_path: argv[0],
    output_format: "json",
    api_key: nil,
    format: "csv",
    quiet: false
  }

  i = 1  # Start after the file path
  while i < argv.length
    arg = argv[i]
    case arg
    when "--count"
      args[:count] = argv[i + 1].to_i
      i += 2
    when "--title"
      args[:title] = argv[i + 1]
      i += 2
    when "--format"
      args[:format] = argv[i + 1]
      i += 2
    when "--entity-type"
      args[:entity_type] = argv[i + 1]
      i += 2
    when "--entity-description"
      args[:entity_description] = argv[i + 1]
      i += 2
    when "--csv-identifier"
      args[:csv_identifier] = argv[i + 1].to_i
      i += 2
    when "--metadata"
      args[:metadata] = parse_json_or_file(argv[i + 1])
      i += 2
    when "--quiet"
      args[:quiet] = true
      i += 1
    when "--api-key"
      args[:api_key] = argv[i + 1]
      i += 2
    when "--output-format"
      args[:output_format] = argv[i + 1]
      i += 2
    else
      $stderr.puts "Unknown option: #{arg}"
      exit 1
    end
  end

  args
end

# Main execution
begin
  args = parse_args(ARGV)

  # Validate required parameters
  unless args[:count]
    $stderr.puts "Error: --count is required"
    $stderr.puts "Run 'exa-ai import-create --help' for usage information"
    exit 1
  end

  unless args[:title]
    $stderr.puts "Error: --title is required"
    $stderr.puts "Run 'exa-ai import-create --help' for usage information"
    exit 1
  end

  unless args[:entity_type]
    $stderr.puts "Error: --entity-type is required"
    $stderr.puts "Run 'exa-ai import-create --help' for usage information"
    exit 1
  end

  # Validate format
  unless VALID_FORMATS.include?(args[:format])
    $stderr.puts "Error: format must be one of: #{VALID_FORMATS.join(', ')}"
    exit 1
  end

  # Validate entity type
  unless VALID_ENTITY_TYPES.include?(args[:entity_type])
    $stderr.puts "Error: entity-type must be one of: #{VALID_ENTITY_TYPES.join(', ')}"
    exit 1
  end

  # Validate entity-description for custom entity type
  if args[:entity_type] == "custom"
    unless args[:entity_description]
      $stderr.puts "Error: --entity-description is required when --entity-type is 'custom'"
      $stderr.puts "Run 'exa-ai import-create --help' for usage information"
      exit 1
    end
  elsif args[:entity_description]
    $stderr.puts "Warning: --entity-description is only used with --entity-type custom (ignoring)"
  end

  # Validate file exists
  unless File.exist?(args[:file_path])
    $stderr.puts "Error: File not found: #{args[:file_path]}"
    exit 1
  end

  # Resolve API key
  api_key = Exa::CLI::Base.resolve_api_key(args[:api_key])

  # Resolve output format
  output_format = Exa::CLI::Base.resolve_output_format(args[:output_format])

  # Build client
  client = Exa::CLI::Base.build_client(api_key)

  # Prepare import parameters
  entity = { type: args[:entity_type] }
  entity[:description] = args[:entity_description] if args[:entity_description]

  import_params = {
    file_path: args[:file_path],
    count: args[:count],
    title: args[:title],
    format: args[:format],
    entity: entity
  }
  import_params[:metadata] = args[:metadata] if args[:metadata]

  # Add CSV config if csv_identifier provided
  if args[:csv_identifier]
    import_params[:csv] = { identifier: args[:csv_identifier] }
  end

  # Show upload message unless quiet
  unless args[:quiet]
    file_size = File.size(args[:file_path])
    $stderr.puts "Uploading #{args[:file_path]} (#{file_size} bytes)..."
  end

  # Upload import
  import = client.upload_import(**import_params)

  # Show success message unless quiet
  unless args[:quiet]
    $stderr.puts "Upload complete. Import ID: #{import.id}"
  end

  # Format and output result (unless quiet)
  unless args[:quiet]
    output = Exa::CLI::Formatters::ImportFormatter.format(import, output_format)
    puts output
  end

rescue Exa::ConfigurationError => e
  $stderr.puts "Configuration error: #{e.message}"
  exit 1
rescue Exa::Unauthorized => e
  $stderr.puts "Authentication error: #{e.message}"
  $stderr.puts "Check your API key (set EXA_API_KEY or use --api-key)"
  exit 1
rescue Exa::ClientError => e
  $stderr.puts "Client error: #{e.message}"
  exit 1
rescue Exa::ServerError => e
  $stderr.puts "Server error: #{e.message}"
  $stderr.puts "The Exa API may be experiencing issues. Please try again later."
  exit 1
rescue Exa::Error => e
  $stderr.puts "Error: #{e.message}"
  exit 1
rescue StandardError => e
  $stderr.puts "Unexpected error: #{e.message}"
  $stderr.puts e.backtrace.first(5) if ENV["DEBUG"]
  exit 1
end
