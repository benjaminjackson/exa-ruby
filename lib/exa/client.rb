# frozen_string_literal: true

module Exa
  # Main client for interacting with the Exa.ai API
  #
  # Provides methods for all supported Exa.ai operations including search,
  # content retrieval, answer generation, and async research tasks.
  #
  # @example Basic usage
  #   client = Exa::Client.new(api_key: "your-key")
  #   results = client.search("ruby on rails")
  #   results.results.each { |r| puts r.title }
  #
  # @example Using configuration
  #   Exa.configure { |config| config.api_key = "your-key" }
  #   client = Exa::Client.new
  class Client
    # Initialize a new Exa client
    #
    # @param api_key [String, nil] API key for authentication. Falls back to Exa.api_key if not provided
    # @param options [Hash] Connection options
    # @option options [String] :base_url Custom API base URL (default: https://api.exa.ai)
    # @option options [Integer] :timeout Request timeout in seconds (default: 30)
    # @raise [ConfigurationError] If API key is not provided and not configured
    def initialize(api_key: nil, **options)
      @api_key = api_key || Exa.api_key
      @options = options

      validate_api_key!
    end

    # Execute a search query
    #
    # @param query [String] Search query
    # @param params [Hash] Additional search parameters
    # @option params [String] :type Search type (web, news, etc.)
    # @option params [Array<String>] :include_domains Domains to include in results
    # @option params [Array<String>] :exclude_domains Domains to exclude from results
    # @option params [Integer] :num_results Number of results to return
    # @return [Resources::SearchResult] Search results with metadata
    def search(query, **params)
      Services::Search.new(connection, query: query, **params).call
    end

    # Find similar content to a given URL
    #
    # @param url [String] URL to find similar content for
    # @param options [Hash] Search options
    # @option options [Integer] :num_results Number of results to return
    # @return [Resources::SearchResult] Similar results
    def find_similar(url, **options)
      Services::FindSimilar.new(connection, url: url, **options).call
    end

    # Get full page contents for URLs
    #
    # @param urls [Array<String>, String] URL or URLs to fetch contents for
    # @param options [Hash] Fetch options
    # @return [Resources::ContentCollection] Collection of page contents
    def get_contents(urls, **options)
      Services::GetContents.new(connection, urls: urls, **options).call
    end

    # Get AI-generated answers to a query
    #
    # @param query [String] Question or query
    # @param options [Hash] Answer options
    # @option options [String] :format Response format (default: standard)
    # @return [Resources::Answer] AI-generated answer with sources
    def answer(query, **options)
      Services::Answer.new(connection, query: query, **options).call
    end

    # Stream AI-generated answers to a query
    #
    # Returns partial answer chunks as they are generated by the API.
    #
    # @param query [String] Question or query
    # @param options [Hash] Answer options
    # @option options [Boolean] :text Include full text content (default: false)
    # @option options [Hash] :output_schema JSON schema for structured output
    # @yield [chunk] Yields each answer chunk as it arrives
    # @yieldparam chunk [Hash] Partial answer data with {"answer" => "text"}
    # @return [void]
    def answer_stream(query, **options, &block)
      Services::AnswerStream.new(connection, query: query, **options).call(&block)
    end

    # Start an asynchronous research task
    #
    # @param params [Hash] Research parameters
    # @return [Resources::Research] Research task with ID
    def research_start(**params)
      Services::ResearchStart.new(connection, **params).call
    end

    # List all research tasks
    #
    # @param params [Hash] Listing parameters
    # @option params [Integer] :limit Maximum number of tasks to return
    # @return [Resources::ResearchList] List of research tasks
    def research_list(**params)
      Services::ResearchList.new(connection, **params).call
    end

    # Get status and results of a research task
    #
    # @param research_id [String] Research task ID
    # @param params [Hash] Fetch options
    # @return [Resources::Research] Research task with current status and results
    def research_get(research_id, **params)
      Services::ResearchGet.new(connection, research_id: research_id, **params).call
    end

    # Search code repositories
    #
    # @param query [String] Code search query
    # @param params [Hash] Search parameters
    # @option params [Array<String>] :languages Programming languages to search
    # @return [Resources::SearchResult] Code search results
    def context(query, **params)
      Services::Context.new(connection, query: query, **params).call
    end

    # List all websets
    #
    # @param params [Hash] Pagination parameters
    # @option params [String] :cursor Cursor for pagination
    # @option params [Integer] :limit Maximum number of websets to return
    # @return [Resources::WebsetCollection] Paginated list of websets
    def list_websets(**params)
      Services::Websets::List.new(connection, **params).call
    end

    # Get a specific webset by ID
    #
    # @param id [String] Webset ID
    # @param params [Hash] Optional parameters
    # @option params [Array<String>] :expand Resources to expand in response (e.g., ['items'])
    # @return [Resources::Webset] The requested webset
    def get_webset(id, **params)
      Services::Websets::Retrieve.new(connection, id: id, **params).call
    end

    # Delete a webset
    #
    # @param id [String] Webset ID
    # @return [Resources::Webset] The deleted webset
    def delete_webset(id)
      Services::Websets::Delete.new(connection, id: id).call
    end

    # Cancel in-progress operations on a webset
    #
    # @param id [String] Webset ID
    # @return [Resources::Webset] The webset with cancelled operations
    def cancel_webset(id)
      Services::Websets::Cancel.new(connection, id: id).call
    end

    # Update a webset's metadata
    #
    # @param id [String] Webset ID
    # @param params [Hash] Update parameters
    # @option params [Hash] :metadata Metadata to update
    # @return [Resources::Webset] The updated webset
    def update_webset(id, **params)
      Services::Websets::Update.new(connection, id: id, **params).call
    end

    # Create a new webset
    #
    # @param params [Hash] Creation parameters
    # @option params [Hash] :search Search configuration
    # @return [Resources::Webset] The newly created webset
    def create_webset(**params)
      Services::Websets::Create.new(connection, **params).call
    end

    # Create a new enrichment for a webset
    #
    # @param webset_id [String] Webset ID
    # @param params [Hash] Enrichment parameters
    # @option params [String] :description Description of data to extract
    # @option params [String] :format Format type (text, url, options, etc.)
    # @option params [Array<Hash>] :options Options for enrichment
    # @option params [Hash] :metadata Custom metadata
    # @return [Resources::WebsetEnrichment] The newly created enrichment
    def create_enrichment(webset_id:, **params)
      Services::Websets::CreateEnrichment.new(connection, webset_id: webset_id, **params).call
    end

    # Get a specific enrichment by ID
    #
    # @param webset_id [String] Webset ID
    # @param id [String] Enrichment ID
    # @return [Resources::WebsetEnrichment] The requested enrichment
    def get_enrichment(webset_id:, id:)
      Services::Websets::RetrieveEnrichment.new(connection, webset_id: webset_id, id: id).call
    end

    # Update an enrichment
    #
    # @param webset_id [String] Webset ID
    # @param id [String] Enrichment ID
    # @param params [Hash] Update parameters
    # @option params [String] :description Updated description
    # @option params [String] :format Updated format
    # @option params [Array<Hash>] :options Updated options
    # @option params [Hash] :metadata Updated metadata
    # @return [Resources::WebsetEnrichment] The updated enrichment
    def update_enrichment(webset_id:, id:, **params)
      Services::Websets::UpdateEnrichment.new(connection, webset_id: webset_id, id: id, **params).call
    end

    # Delete an enrichment
    #
    # @param webset_id [String] Webset ID
    # @param id [String] Enrichment ID
    # @return [Resources::WebsetEnrichment] The deleted enrichment
    def delete_enrichment(webset_id:, id:)
      Services::Websets::DeleteEnrichment.new(connection, webset_id: webset_id, id: id).call
    end

    # Cancel a running enrichment
    #
    # @param webset_id [String] Webset ID
    # @param id [String] Enrichment ID
    # @return [Resources::WebsetEnrichment] The cancelled enrichment
    def cancel_enrichment(webset_id:, id:)
      Services::Websets::CancelEnrichment.new(connection, webset_id: webset_id, id: id).call
    end

    # Create a new search within a webset
    #
    # @param webset_id [String] Webset ID
    # @param params [Hash] Search parameters
    # @option params [String] :query The search query (required)
    # @option params [Integer] :count Number of results to find
    # @option params [Hash] :entity Entity type specification
    # @option params [Array<Hash>] :criteria Search criteria
    # @option params [Array<Hash>] :exclude Items to exclude from results
    # @option params [Array<Hash>] :scope Limit search to specific sources
    # @option params [Boolean] :recall Whether to estimate total available results
    # @option params [String] :behavior "override" or "append" (default: "override")
    # @option params [Hash] :metadata Custom metadata
    # @return [Resources::WebsetSearch] The newly created search
    def create_webset_search(webset_id:, **params)
      Services::Websets::CreateSearch.new(connection, webset_id: webset_id, **params).call
    end

    # Get a webset search by ID
    #
    # @param webset_id [String] Webset ID
    # @param id [String] Search ID
    # @return [Resources::WebsetSearch] The requested search
    def get_webset_search(webset_id:, id:)
      Services::Websets::GetSearch.new(connection, webset_id: webset_id, id: id).call
    end

    # Cancel a webset search
    #
    # @param webset_id [String] Webset ID
    # @param id [String] Search ID
    # @return [Resources::WebsetSearch] The cancelled search
    def cancel_webset_search(webset_id:, id:)
      Services::Websets::CancelSearch.new(connection, webset_id: webset_id, id: id).call
    end

    # Get a webset item by ID
    #
    # @param webset_id [String] Webset ID
    # @param id [String] Item ID
    # @return [Hash] The requested item
    def get_item(webset_id:, id:)
      Services::Websets::GetItem.new(connection, webset_id: webset_id, id: id).call
    end

    # Delete a webset item by ID
    #
    # @param webset_id [String] Webset ID
    # @param id [String] Item ID
    # @return [Boolean] True if deletion was successful
    def delete_item(webset_id:, id:)
      Services::Websets::DeleteItem.new(connection, webset_id: webset_id, id: id).call
    end

    # List all items in a webset
    #
    # @param webset_id [String] Webset ID
    # @param params [Hash] Pagination parameters
    # @option params [String] :cursor Cursor for pagination
    # @option params [Integer] :limit Maximum number of items to return (default: 20)
    # @return [Resources::WebsetItemCollection] Paginated list of items
    def list_items(webset_id:, **params)
      Services::Websets::ListItems.new(connection, webset_id: webset_id, **params).call
    end

    # List all imports
    #
    # @param params [Hash] Pagination parameters
    # @option params [String] :cursor Cursor for pagination
    # @option params [Integer] :limit Maximum number of imports to return
    # @return [Resources::ImportCollection] Paginated list of imports
    def list_imports(**params)
      Services::Websets::ListImports.new(connection, **params).call
    end

    # Create a new import
    #
    # @param params [Hash] Import parameters
    # @option params [Integer] :size Size of the import file
    # @option params [Integer] :count Number of items to import
    # @option params [String] :title Import title
    # @option params [String] :format Import format (e.g., "csv")
    # @option params [Hash] :entity Entity type specification
    # @option params [Hash] :metadata Custom metadata
    # @option params [Hash] :csv CSV-specific configuration
    # @return [Resources::Import] The newly created import
    def create_import(**params)
      Services::Websets::CreateImport.new(connection, **params).call
    end

    # Upload a file for import (creates import and uploads file)
    #
    # @param file_path [String] Path to the file to upload
    # @param params [Hash] Import parameters
    # @option params [Integer] :count Number of items to import
    # @option params [String] :title Import title
    # @option params [String] :format Import format (e.g., "csv")
    # @option params [Hash] :entity Entity type specification
    # @option params [Hash] :metadata Custom metadata
    # @option params [Hash] :csv CSV-specific configuration
    # @return [Resources::Import] The created import (file size is inferred automatically)
    def upload_import(file_path:, **params)
      Services::Websets::UploadImport.new(connection, file_path: file_path, **params).call
    end

    # Get a specific import by ID
    #
    # @param id [String] Import ID
    # @return [Resources::Import] The requested import
    def get_import(id)
      Services::Websets::GetImport.new(connection, id: id).call
    end

    # Update an import
    #
    # @param id [String] Import ID
    # @param params [Hash] Update parameters
    # @option params [String] :title Updated title
    # @option params [Hash] :metadata Updated metadata
    # @return [Resources::Import] The updated import
    def update_import(id, **params)
      Services::Websets::UpdateImport.new(connection, id: id, **params).call
    end

    # Delete an import
    #
    # @param id [String] Import ID
    # @return [Resources::Import] The deleted import
    def delete_import(id)
      Services::Websets::DeleteImport.new(connection, id: id).call
    end

    # Create a new monitor for a webset
    #
    # @param webset_id [String] Webset ID
    # @param cadence [Hash] Schedule configuration with :cron and :timezone
    # @param behavior [Hash] Behavior configuration (type, query, etc.)
    # @param params [Hash] Additional monitor parameters
    # @option params [Hash] :metadata Custom metadata
    # @return [Resources::Monitor] The newly created monitor
    def create_monitor(webset_id:, cadence:, behavior:, **params)
      Services::Websets::Monitors::Create.new(connection, webset_id: webset_id, cadence: cadence, behavior: behavior, **params).call
    end

    # List all monitors
    #
    # @param params [Hash] Pagination parameters
    # @option params [String] :cursor Cursor for pagination
    # @option params [Integer] :limit Maximum number of monitors to return
    # @return [Resources::MonitorCollection] Paginated list of monitors
    def list_monitors(**params)
      Services::Websets::Monitors::List.new(connection, **params).call
    end

    # Get a specific monitor by ID
    #
    # @param id [String] Monitor ID
    # @return [Resources::Monitor] The requested monitor
    def get_monitor(id:)
      Services::Websets::Monitors::Get.new(connection, id: id).call
    end

    # Update a monitor
    #
    # @param id [String] Monitor ID
    # @param params [Hash] Update parameters
    # @option params [Hash] :cadence Updated schedule configuration
    # @option params [Hash] :behavior Updated behavior configuration
    # @option params [Hash] :metadata Updated metadata
    # @return [Resources::Monitor] The updated monitor
    def update_monitor(id:, **params)
      Services::Websets::Monitors::Update.new(connection, id: id, **params).call
    end

    # Delete a monitor
    #
    # @param id [String] Monitor ID
    # @return [Resources::Monitor] The deleted monitor
    def delete_monitor(id:)
      Services::Websets::Monitors::Delete.new(connection, id: id).call
    end

    # List all runs for a specific monitor
    #
    # @param monitor_id [String] Monitor ID
    # @param params [Hash] Pagination parameters
    # @option params [String] :cursor Cursor for pagination
    # @option params [Integer] :limit Maximum number of runs to return
    # @return [Resources::MonitorRunCollection] Paginated list of monitor runs
    def list_monitor_runs(monitor_id:, **params)
      Services::Websets::Monitors::Runs::List.new(connection, monitor_id: monitor_id, **params).call
    end

    # Get a specific monitor run by ID
    #
    # @param monitor_id [String] Monitor ID
    # @param id [String] Run ID
    # @return [Resources::MonitorRun] The requested monitor run
    def get_monitor_run(monitor_id:, id:)
      Services::Websets::Monitors::Runs::Get.new(connection, monitor_id: monitor_id, id: id).call
    end

    private

    def connection
      @connection ||= Connection.build(
        api_key: @api_key,
        **connection_options
      )
    end

    def connection_options
      options = {}
      options[:base_url] = @options[:base_url] if @options[:base_url]
      options[:timeout] = @options[:timeout] if @options[:timeout]
      options[:debug] = true if ENV["EXA_DEBUG"]
      options
    end

    def validate_api_key!
      return if @api_key && !@api_key.empty?

      raise ConfigurationError, "API key is required. Set it with Exa.configure or pass it to Client.new"
    end
  end
end
